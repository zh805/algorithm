不难发现，位置`i`左边有几个零，`i`就要向右移动几位，因为左边的零个数会翻倍
知道左边零的个数，就能知道最终会落在哪里

原地修改需要注意的点：
如果正序遍历，把数字向右覆盖，会导致后面的的数还没遍历到，就被覆盖了
使用倒序遍历可避免这一点，向右覆盖的都是已经遍历过的数

* java

```java
class Solution {
    public void duplicateZeros(int[] A) {
        int n = A.length, cnt0 = 0;
        // 先统计零的总数
        for (int i = 0; i < n; ++i) if (A[i] == 0) ++cnt0;
        for (int i = n - 1; i >= 0; --i) {
            // 碰到零就减去，剩余的就是左边零的个数
            if (A[i] == 0) --cnt0;
            // A[i] 向右移动 cnt0 位
            if (i + cnt0 < n) {
                A[i + cnt0] = A[i];
                // 如果 A[i] 是零，移动完之后，后面还要补个零
                if (A[i] == 0 && i + cnt0 + 1 < n) {
                    A[i + cnt0 + 1] = 0;
                }
            }
        }
    }
}
```

- 时间复杂度 `O(N)`
- 空间复杂度 `O(1)`


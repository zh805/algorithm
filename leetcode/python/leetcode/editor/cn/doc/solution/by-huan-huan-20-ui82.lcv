### $\textcolor{green}{思路一\ 动态规划}$

二叉搜索树左子树的节点值 < 根节点值 < 右子树节点值，左右子树上的节点也一样。

给定有序序列1...n，我们可以依次选取1,2,...,n作为根节点，当选取i为根节点时，1,...,i-1作为生成左子树的节点（i-1个节点），i+1,...,n作为生成右子树的节点（n-i个节点），对于1,...,i-1和i+1,...,n中的值也以一样的思路，递归处理。不难发现出现了2个重叠的子问题，可以采用动态规划的思想求解，首先分别定义两个子问题。

G(n)为序列n可以生成不同二叉搜索树的数目，f(i,n)为以i为根节点，序列长度为n(1<=i<=n)生成不同二叉搜索树的数目。当选取i为根节点时，1,...,i-1作为生成左子树的节点（i-1个节点）可以生成G(i-1)个不同的二叉搜索树，i+1,...,n作为生成右子树的节点（n-i个节点）可以生成G(n-i)个不同的二叉搜索树，则$f(i,n) = G(i-1) \times G(n-i)$。给定有序序列1...n，我们可以依次选取1,2,...,n作为根节点，所以G(n) = f(i,n)中i从1遍历到n的和，即$G(n) = \sum^n_1f(i,n)$。将第一个公式的f带入到G中可得$G(n)=\sum^n_1G(i-1) \times G(n-i),(1<=i<=n)$，这就是动态规划的状态转化方程了。

用dp记录，为了状态的转化，初始时dp[0] = 1，dp[1] = 1（只有一个节点时只能生成一棵树）。状态转移时可以采用双重循环，内层循环算用于求和的各项G的值，外层用于计算总的G(n)，1<=i<=n，所以外层的i范围为2到n（用range则是range(2,n+1)，因为range不包括结尾的值），内层的为1到外层的i（用range则是range(1,i+1)），最后返回dp[n]或dp[-1]即为答案。

* python

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0 for _ in range(n+1)]
        dp[0], dp[1] = 1, 1
        for i in range(2,n+1):
            for j in range(1,i+1):
                dp[i] += dp[j-1] * dp[i-j]
        return dp[-1]
```


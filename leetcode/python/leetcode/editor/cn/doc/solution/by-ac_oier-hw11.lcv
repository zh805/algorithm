## 数学

给定的 $(sx, sy)$ 的数据范围为 $[1, 10^9]$（即均为正整数），且每次转换，只能将另外一维的数值累加到当前维，因此对于每一维的数值而言，随着转换次数的进行，呈（非严格）递增趋势，再结合起始值为正整数，可知在转换过程中均不会出现负数。

**由此得知从 $(tx, ty)$ 到 $(sx, sy)$ 的转换过程唯一确定：总是取较大数减去较小数来进行反推（否则会出现负数）。**

但即使反向转换唯一确定，数据范围为 $10^9$，线性模拟仍会超时。

我们考虑将「相同操作的连续段转换动作」进行合并，在某次反向转换中，如果有 $tx < ty$，我们会将 $(tx, ty)$ 转换为 $(tx, ty - tx)$，若相减完仍有 $tx < ty - tx$，该操作会继续进行，得到 $(tx, ty - 2 * tx)$，直到不满足 $tx < ty - k * tx$，其中 $k$ 为转换次数。

即对于一般性的情况而言，$(tx, ty)$ 中的较大数会一直消减到「与较小数的余数」为止。

因此我们可以先使用 $O(\log{max(tx, ty)})$ 的复杂度将其消减到不超过 $(sx, sy)$ 为止。此时如果消减后的结果 $(tx, ty)$ 任一维度小于 $(sx, sy)$，必然不能进行转换，返回 `False`；如果任一维度相等（假定是 $x$ 维度），则检查另一维度（$y$ 维度）的差值，能够由当前维度（$x$ 维度）拼凑而来。

代码：

* []

```Java
class Solution {
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        while (sx < tx && sy < ty) {
            if (tx < ty) ty %= tx;
            else tx %= ty;
        }
        if (tx < sx || ty < sy) return false;
        return sx == tx ? (ty - sy) % tx == 0 : (tx - sx) % ty == 0;
    }
}
```

* 时间复杂度：$O(\log{\max(tx, ty)})$
* 空间复杂度：$O(1)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~

**小小的总结**
求两个数组或者字符串的子序列问题，肯定是要用动态规划的。
首先，区分两个概念：
- 子序列可以是不连续的；
- 子数组（子字符串）需要是连续的；
  另外，动态规划也是有套路的：
- 当单个数组或者字符串要用动态规划时，可以把动态规划 dp[i] 定义为 nums[0:i] 中想要求的结果；
- 当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 dp[i][j] ，其含义是在 A[0:i-1] 与 B[0:j-1] 之间匹配得到的想要的结果。

**思路分析**
s 、t 字符串各抽出一个前缀子字符串，判断s是否是t的子序列就是要在 t 中查找到 一个s 。问题等价转换在t中找到和s相同子序列的长度==s的大小
- 如果末尾项不一样
  - 此时相当于 t 要删除元素（就是s的当前字符和t的下一个字符在进行比较），t 如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即 dp[i][j] = dp[i][j - 1];
- 如果末尾项一样，以它们俩为末尾项的相同子序列长度取决于dp[i-1][j-1]能为它们俩提供多大的相同子序列长度然后加1
  - 因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1][j-1]的基础上加1即 dp[i][j] = dp[i-1][j-1] + 1

**动态规划算法**
**1. 确定dp数组以及下标的含义：**
- dp[i][j] ：长度为i，末尾项为s[i-1]的子字符串，与长度为j，末尾项为t[j-1]的子字符串，二者的相同子序列长度。

**2. 确定递推公式：**
- 如果 s[i-1] != t[j-1]， 有 dp[i][j] = dp[i][j-1]
- 如果 s[i-1] == t[j-1] ， 有 dp[i][j] = dp[i-1][j-1] + 1

**3. 初始状态：**
- 如果 i==0 || j==0 ，则二者没有公共部分，dp[i][j]=0

**4. 返回值：**
- dp[i][j]的最大值是否和s的大小一样长。

* 

```
class Solution {
public:
    bool isSubsequence(string s, string t) {
        /* 如果要想s是t的子序列首先是t的长度要大于s的长度 */
        if(s.size() > t.size()) return false;
        /* 定义dp数组 */
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        /* dp数组初始化 dp[i][0]=0,dp[0][j]=0 */
        for(int i = 1; i <= s.size(); i++) {
            for(int j = 1; j <= t.size(); j++) {
                /* 找到一个字符 个数加1 */
                if(s[i-1] == t[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                /* 没有找到这需要t往前查找 */
                else {
                    dp[i][j] = dp[i][j-1];
                }
            }
        }
        if(dp[s.size()][t.size()] == s.size()) return true;
        return false;
    }
};
```


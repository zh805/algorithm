## 前言

这是一篇经过修缮的题解，原始的版本在 [这里](https://leetcode-cn.com/problems/out-of-boundary-paths/solution/dong-tai-gui-hua-suo-you-lu-jing-wen-ti-94bal/) 。

当时是作为《DP-路径问题》的第九讲进行呈现，里面有较多的「前程提要」的部分，所以不太能作为一篇独立题解进行阅读。

因此本题主要是对原始版本做一个简化，当然如果你在 [LeetBook](https://leetcode-cn.com/leetbook/detail/path-problems-in-dynamic-programming/) 或者 [公主号](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE3MTEyMA==&action=getalbum&album_id=1773144264147812354&scene=173&from_msgid=2247485297&from_itemidx=1&count=3&nolastread=1#wechat_redirect) 看过《DP-路径问题》系列的话，直接看 [原始版](https://leetcode-cn.com/problems/out-of-boundary-paths/solution/dong-tai-gui-hua-suo-you-lu-jing-wen-ti-94bal/) 也是没有问题的。

---

## 基本分析

通常来说，朴素的路径 DP 问题之所以能够使用常规 DP 方式进行求解，是因为只能往某一个方向（一维棋盘的路径问题）或者只能往某两个方向（二维棋盘的路径问题）移动。

这样的移动规则意味着，我们不会重复进入同一个格子。

**从图论的意义出发：将每个格子视为点的话，如果能够根据移动规则从 `a` 位置一步到达 `b` 位置，则说明存在一条由 `a` 指向 `b` 的有向边。**

**也就是说，在朴素的路径 DP 问题中，“单向”的移动规则注定了我们的图不存在环，是一个存在拓扑序的有向无环图，因此我们能够使用常规 DP 手段来求解。**

回到本题，移动规则是四联通，并不是“单向”的，在某条出界的路径中，我们是有可能重复进入某个格子，即存在环。

因此我们需要换一种 DP 思路进行求解。

---

## 记忆化搜索

通常在直接 DP 不好入手的情况下，我们可以先尝试写一个「记忆化搜索」的版本。

那么如果是让你设计一个 DFS 函数来解决本题，你会如何设计？

我大概会这样设计：

* []

```Java
int dfs(int x, int y, int k) {}
```

重点放在几个「可变参数」与「返回值」上：$(x,y)$ 代表当前所在的位置，$k$ 代表最多使用多少步，返回值代表路径数量。

根据 [DP-动态规划 第八讲](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485297&idx=1&sn=5ee4ce31c42d368af0653f60aa263c82&chksm=fd9cac6ecaeb25787e6da90423c5467e1679da0a8aaf1a3445475199a8f148d8629e851fea57&scene=178&cur_album_id=1773144264147812354#rd) 的学习中，我们可以确定递归出口为：

1. 当前到达了棋盘外的位置，说明找到了一条出界路径，返回 $1$；
2. 在条件 $1$ 不满足的前提下，当剩余步数为 $0$（不能再走下一步），说明没有找到一条合法的出界路径，返回 $0$。

主逻辑则是根据四联通规则进行移动即可，最终答案为 `dfs(startRow, startColumn, maxMove)`。

代码：

* []

```Java
class Solution {
    int MOD = (int)1e9+7;
    int m, n, max;
    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    int[][][] cache;
    public int findPaths(int _m, int _n, int _max, int r, int c) {
        m = _m; n = _n; max = _max;
        cache = new int[m][n][max + 1];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k <= max; k++) {
                    cache[i][j][k] = -1;
                }
            }
        }
        return dfs(r, c, max);
    }
    int dfs(int x, int y, int k) {
        if (x < 0 || x >= m || y < 0 || y >= n) return 1;
        if (k == 0) return 0;
        if (cache[x][y][k] != -1) return cache[x][y][k];
        int ans = 0;
        for (int[] d : dirs) {
            int nx = x + d[0], ny = y + d[1];
            ans += dfs(nx, ny, k - 1);
            ans %= MOD;
        }
        cache[x][y][k] = ans;
        return ans;
    }
}
```

---

## 动态规划

根据我们的「记忆化搜索」，我们可以设计一个二维数组 $f[][]$ 作为我们的 dp 数组：

* **第一维代表 DFS 可变参数中的 $(x,y)$ 所对应 $index$。取值范围为 $[0, m*n)$**
* **第二维代表 DFS 可变参数中的 $k$。取值范围为 $[0,max]$**

**dp 数组中存储的就是我们 `DFS` 的返回值：路径数量。**

根据 dp 数组中的维度设计和存储目标值，我们可以得知「状态定义」为：

**$f[i][j]$ 代表从位置 $i$ 出发，可用步数不超过 $j$ 时的路径数量。**

至此，我们只是根据「记忆化搜索」中的 `DFS` 函数的签名，就已经得出我们的「状态定义」了，接下来需要考虑「转移方程」。

当有了「状态定义」之后，我们需要从「最后一步」来推导出「转移方程」：

由于题目允许往四个方向进行移动，因此我们的最后一步也要统计四个相邻的方向。

由此可得我们的状态转移方程：

$$
f[(x,y)][step] = f[(x-1,y)][step-1]+f[(x+1,y)][step-1]+f[(x,y-1)][step-1]+f[(x,y+1)][step-1]
$$

注意，转移方程中 dp 数组的第一维存储的是 $(x,y)$ 对应的 $idx$。

从转移方程中我们发现，更新 $f[i][j]$ 依赖于 $f[x][j-1]$，因此我们转移过程中需要将最大移动步数进行「从小到大」枚举。

至此，我们已经完成求解「路径规划」问题的两大步骤：「状态定义」&「转移方程」。

但这还不是所有，我们还需要一些 **有效值** 来滚动下去。

**其实就是需要一些「有效值」作为初始化状态。**

观察我们的「转移方程」可以发现，整个转移过程是一个累加过程，如果没有一些有效的状态（非零值）进行初始化的话，整个递推过程并没有意义。

那么哪些值可以作为成为初始化状态呢？

显然，当我们已经位于矩阵边缘的时候，我们可以一步跨出矩阵，这算作一条路径。

同时，由于我们能够往四个方向进行移动，因此不同的边缘格子会有不同数量的路径。

![image.png](https://pic.leetcode-cn.com/1616507893-KjPAvs-image.png)

换句话说，我们需要先对边缘格子进行初始化操作，预处理每个边缘格子直接走出矩阵的路径数量。

目的是为了我们整个 DP 过程可以有效的递推下去。

**可以发现，动态规划的实现，本质是将问题进行反向：原问题是让我们求从棋盘的特定位置出发，出界的路径数量。实现时，我们则是从边缘在状态出发，逐步推导回起点的出界路径数量为多少。**

代码：

* []

```Java
class Solution {
    int MOD = (int)1e9+7;
    int m, n, max;
    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    public int findPaths(int _m, int _n, int _max, int r, int c) {
        m = _m; n = _n; max = _max;
        int[][] f = new int[m * n][max + 1];
        // 初始化边缘格子的路径数量
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0) add(i, j, f);
                if (j == 0) add(i, j, f);
                if (i == m - 1) add(i, j, f);
                if (j == n - 1) add(i, j, f);
            }
        }
        // 从小到大枚举「可移动步数」
        for (int k = 1; k <= max; k++) {
            // 枚举所有的「位置」
            for (int idx = 0; idx < m * n; idx++) {
                int[] info = parseIdx(idx);
                int x = info[0], y = info[1];
                for (int[] d : dirs) {
                    int nx = x + d[0], ny = y + d[1];
                    if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
                    int nidx = getIdx(nx, ny);
                    f[idx][k] += f[nidx][k - 1];
                    f[idx][k] %= MOD;
                }
            }
        }
        return f[getIdx(r, c)][max];       
    }
    void add(int x, int y, int[][] f) {
        for (int k = 1; k <= max; k++) {
            f[getIdx(x, y)][k]++;
        }
    }
    int getIdx(int x, int y) {
        return x * n + y;
    }
    int[] parseIdx(int idx) {
        return new int[]{idx / n, idx % n};
    }
}
```

* 时间复杂度：共有 $m * n * max$ 个状态需要转移，复杂度为 $O(m * n * max)$
* 空间复杂度：$O(m * n * max)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png)（公主号后台回复「送书」即可参与看题解学算法送实体书长期活动）或 加入[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~
